# Задание: Применение Принципа Открытости/Закрытости (Open/Closed Principle) в Разработке Простой Игры
# Цель: Цель этого домашнего задание - закрепить понимание и навыки применения принципа открытости/закрытости (Open/Closed Principle), одного из пяти SOLID принципов объектно-ориентированного программирования. Принцип гласит, что программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.
# Задача: Разработать простую игру, где игрок может использовать различные типы оружия для борьбы с монстрами. Программа должна быть спроектирована таким образом, чтобы легко можно было добавлять новые типы оружия, не изменяя существующий код бойцов или механизм боя.
# Исходные данные:
# Есть класс Fighter, представляющий бойца.
# Есть класс Monster, представляющий монстра.
# Игрок управляет бойцом и может выбирать для него одно из вооружений для боя.

# Шаг 1: Создайте абстрактный класс для оружия.
# Создайте абстрактный класс Weapon, который будет содержать абстрактный метод attack().

# Шаг 2: Реализуйте конкретные типы оружия.
# Создайте несколько классов, унаследованных от Weapon, например, Sword и Bow. Каждый из этих классов реализует метод attack() своим уникальным способом.

# Шаг 3: Модифицируйте класс Fighter.
# Добавьте в класс Fighter поле, которое будет хранить объект класса Weapon.
# Добавьте метод change_weapon(), который позволяет изменить оружие бойца.

# Шаг 4: Реализация боя.
# Реализуйте простой механизм для демонстрации боя между бойцом и монстром, исходя из выбранного оружия.

# Требования к заданию:
# Код должен быть написан на Python.
# Программа должна демонстрировать применение принципа открытости/закрытости: новые типы оружия можно легко добавлять, не изменяя существующие классы бойцов и механизм боя.
# Программа должна выводить результат боя в консоль.

# Пример результата:

# Боец выбирает меч.
# Боец наносит удар мечом.
# Монстр побежден!

# Боец выбирает лук.
# Боец наносит удар из лука.
# Монстр побежден!

from abc import ABC, abstractmethod

class Weapon(ABC):
    """Абстрактный класс оружия. Новые типы оружия наследуются от него."""
    @abstractmethod
    def attack(self):
        """Абстрактный метод атаки. Должен быть реализован в подклассах."""
        pass

class Sword(Weapon):
    """Меч — ближний бой."""
    def attack(self):
        return "Боец наносит удар мечом."

class Bow(Weapon):
    """Лук — дальний бой."""
    def attack(self):
        return "Боец стреляет из лука."

class Fighter:
    """Боец, который может менять оружие."""
    def __init__(self, weapon: Weapon):
        self.weapon = weapon

    def change_weapon(self, weapon: Weapon):
        """Смена оружия (принцип инъекции зависимостей)."""
        self.weapon = weapon

    def fight(self):
        """Бой — использует текущее оружие."""
        print(self.weapon.attack())

class Monster:
    """Простой монстр (для демонстрации)."""
    def __init__(self, name):
        self.name = name

def battle(fighter: Fighter, monster: Monster):
    """Механизм боя (не зависит от типа оружия)."""
    print(f"\nБоец выбирает {fighter.weapon.__class__.__name__.lower()}.")
    print(fighter.fight())
    print(f"{monster.name} побежден!")

# Создаем персонажей
fighter = Fighter(Sword())  # Боец с мечом
monster = Monster("Злобный гоблин")

# Демонстрация боя
battle(fighter, monster)

# Меняем оружие и снова боремся
fighter.change_weapon(Bow())
battle(fighter, monster)